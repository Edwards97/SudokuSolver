{"ast":null,"code":"// Container for Sudoku solving strategies\nexport function clearPuzzle() {\n  let clear = [[0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0, 0]];\n  setState({\n    map: clear\n  });\n}\nexport function alreadyContain(element, array) {\n  let answer = false;\n\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === element) {\n      answer = true;\n    }\n  } //end for\n\n\n  return answer;\n}\nexport function oneRule(newMap, i, j) {\n  let possible = [];\n\n  for (let solution = 1; solution !== 10; solution++) {\n    //            console.log(\"possible array contains \" + possible);\n    let column = 0;\n    let row = 0;\n    let isProper = true;\n\n    while (column !== 9) {\n      //check if current column contains number already\n      if (newMap[i][column] === solution) {\n        isProper = false;\n        break;\n      } else if (isProper === false) {\n        break;\n      }\n\n      column++;\n    } //end while w/ column\n\n\n    while (row !== 9) {\n      if (newMap[row][j] === solution) {\n        isProper = false;\n        break;\n      } else if (isProper === false) {\n        break;\n      }\n\n      row++;\n    } //end while w/ row\n\n\n    let x = Math.trunc(i / 3) * 3;\n\n    for (let counter1 = x; counter1 !== x + 3; counter1++) {\n      let y = Math.trunc(j / 3) * 3;\n\n      for (let counter2 = y; counter2 !== y + 3; counter2++) {\n        if (newMap[counter1][counter2] === solution) {\n          isProper = false;\n          break;\n        }\n      } //end for w/ counter2\n\n\n      if (isProper === false) {\n        break;\n      }\n    } //end for w/ counter1 \n\n\n    if (isProper !== false) {\n      possible.push(solution);\n    }\n  } //end for w/ solution     \n\n\n  return possible;\n} //given a grid, and a set of coords returns a guaranteed answer or leaves space blank\n//oneRule checks vertical, horizontal and 3x3 and holds an array of possibilites based on what it finds...\n//if there is only possibilty it pushes that answer into the cell   \n\nexport function deduction(newMap, i, j, possible) {\n  let oldarray = [];\n  let x = Math.trunc(i / 3) * 3;\n\n  for (let counter1 = x; counter1 !== x + 3; counter1++) {\n    let y = Math.trunc(j / 3) * 3;\n\n    for (let counter2 = y; counter2 !== y + 3; counter2++) {\n      if (newMap[counter1][counter2] !== 0) {\n        continue;\n      } else if (counter1 === i && counter2 === j) {\n        continue;\n      } else {\n        let newarray = oneRule(newMap, counter1, counter2);\n        oldarray = newarray.concat(oldarray);\n      }\n    }\n  }\n\n  for (let value1 = 0; value1 < possible.length; value1++) {\n    //iterating through what possibilities are in either array\n    for (let value2 = 0; value2 < oldarray.length; value2++) {\n      if (possible[value1] === oldarray[value2]) {\n        break;\n      }\n\n      if (possible[value1] !== oldarray[value2] && value2 === oldarray.length - 1) {\n        return possible[value1]; //if given index value has one differing value, it is the only possible value\n      }\n    }\n  }\n\n  return 0; //placeholder\n}\nexport function closerLook(newMap) {\n  let allpossibilities = [];\n\n  for (let i = 0; i < newMap.length; i++) {\n    allpossibilities[i] = [];\n\n    for (let j = 0; j < newMap.length; j++) {\n      allpossibilities[i][j] = [];\n\n      if (newMap[i][j] === 0) {\n        allpossibilities[i][j][0] = 0; //found a cell not filled\n\n        allpossibilities[i][j][1] = oneRule(newMap, i, j); //call oneRule\n      } else {\n        allpossibilities[i][j][0] = newMap[i][j]; //cell already filled\n\n        allpossibilities[i][j][1] = 0; //zero possibilities\n      }\n    }\n  }\n\n  console.log(\"called\");\n  return allpossibilities;\n}\nexport function reducePossibilities(allpossibilities, newMap) {\n  for (let i = 0; i < allpossibilities.length; i++) {\n    for (let j = 0; j < allpossibilities[i].length; j++) {\n      if (allpossibilities[i][j][0] === 0) {\n        //identifies cell to be checked if it is empty\n        //look at indexes directly above, below, left and right for a similar possibility\n        let originalPo = allpossibilities[i][j][1];\n        allpossibilities = verticalMatch(originalPo, i, j, allpossibilities, newMap); //look for vertical matches\n\n        allpossibilities = horizontalMatch(originalPo, i, j, allpossibilities, newMap); //look for horizontal matches      \n      } else {\n        continue;\n      }\n    }\n  }\n\n  return allpossibilities;\n}\nexport function horizontalMatch(originalPo, i, j, allpossibilities, newMap) {\n  let x = Math.trunc(i / 3) * 3;\n  let y = Math.trunc(j / 3) * 3;\n\n  for (let column = y; column !== y + 3; column++) {\n    if (j === column) {\n      //if cell is the same\n      continue;\n    } else if (allpossibilities[i][column][1] === 0) {\n      //if cell has zero possibilities... aka already filled\n      continue;\n    } else {\n      //confirmed the comparing cell is empty and not the same as cell [i][j]\n      for (let count1 = 0; count1 < originalPo.length; count1++) {\n        let setValue = [];\n\n        if (alreadyContain(originalPo[count1], allpossibilities[i][column][1]) !== true) {\n          continue;\n        } else {\n          //check to make sure no indices not in this horizontal (i) have this particular possibility\n          for (let count2 = x; count2 !== x + 3; count2++) {\n            for (let count3 = y; count3 !== y + 3; count3++) {\n              if (count2 === i) {\n                // don't look in the same row to determine if to eliminate\n                continue;\n              }\n\n              if (allpossibilities[count2][count3][1] === 0) {\n                // don't look at already filled cells to determine if to eliminate\n                continue;\n              }\n\n              if (alreadyContain(originalPo[count1], allpossibilities[count2][count3][1]) === true) {\n                setValue.push(originalPo[count1]);\n              }\n            } // end for w/ count3\n\n          } // end for w/ count2\n\n        }\n\n        if (alreadyContain(originalPo[count1], setValue) === false) {\n          let iterate = 0;\n\n          while (iterate !== 9) {\n            if (alreadyContain(originalPo[count1], allpossibilities[i][iterate][1]) === true) {\n              if (iterate !== y && iterate !== y + 1 && iterate !== y + 2) {\n                //remove originalPo[count1] from allpossibilities[iterate][j][1]\n                let remove = allpossibilities[i][iterate][1].indexOf(originalPo[count1]);\n\n                if (remove > -1) {\n                  allpossibilities[i][iterate][1].splice(remove, 1);\n                  console.log(\"Horizontal Match found at \" + i + \" \" + j + \" to reduce possibilities at \" + i + \" \" + iterate + \" to be \" + allpossibilities[i][iterate][1]);\n                }\n\n                if (allpossibilities[i][iterate][1].length === 1) {\n                  newMap[i][iterate] = allpossibilities[i][iterate][1][0];\n                  console.log(\"Horizontal Match found \" + i + \" \" + iterate + \" to be \" + allpossibilities[i][iterate][1][0]);\n                }\n              }\n            }\n\n            iterate++;\n          } //iterate through column (j) and eliminate content from other possibility arrays\n\n        }\n      } // end for w/ count1\n\n    }\n  } //end for w/ column\n\n\n  return allpossibilities; //return the row if there is a vertical match (new i)\n}\nexport function verticalMatch(originalPo, i, j, allpossibilities, newMap) {\n  let x = Math.trunc(i / 3) * 3;\n  let y = Math.trunc(j / 3) * 3;\n\n  for (let row = x; row !== x + 3; row++) {\n    if (i === row) {\n      //if cell is the same\n      continue;\n    } else if (allpossibilities[row][j][1] === 0) {\n      //if cell has zero possibilities... aka already filled\n      continue;\n    } else {\n      //confirmed the comparing cell is empty and not the same as cell [i][j]\n      for (let count1 = 0; count1 < originalPo.length; count1++) {\n        let setValue = [];\n\n        if (alreadyContain(originalPo[count1], allpossibilities[row][j][1]) !== true) {\n          continue;\n        } else {\n          //check to make sure no indices not in this vertical (j) have this particular possibility\n          for (let count2 = x; count2 !== x + 3; count2++) {\n            for (let count3 = y; count3 !== y + 3; count3++) {\n              if (count3 === j) {\n                // don't look in the same column to determine if to eliminate\n                continue;\n              }\n\n              if (allpossibilities[count2][count3][1] === 0) {\n                // don't look at already filled cells to determine if to eliminate\n                continue;\n              }\n\n              if (alreadyContain(originalPo[count1], allpossibilities[count2][count3][1]) === true) {\n                setValue.push(originalPo[count1]);\n              }\n            } //end for w/ count3\n\n          } // end for w/ count2\n\n        }\n\n        if (alreadyContain(originalPo[count1], setValue) === false) {\n          let iterate = 0;\n\n          while (iterate !== 9) {\n            if (alreadyContain(originalPo[count1], allpossibilities[iterate][j][1]) === true) {\n              if (iterate !== x && iterate !== x + 1 && iterate !== x + 2) {\n                //remove originalPo[count1] from allpossibilities[iterate][j][1]\n                let remove = allpossibilities[iterate][j][1].indexOf(originalPo[count1]);\n\n                if (remove > -1) {\n                  allpossibilities[iterate][j][1].splice(remove, 1);\n                  console.log(\"Vertical Match found at \" + i + \" \" + j + \" to reduce possibilities at \" + iterate + \" \" + j + \" to be \" + allpossibilities[iterate][j][1]);\n                }\n\n                if (allpossibilities[iterate][j][1].length === 1) {\n                  newMap[iterate][j] = allpossibilities[iterate][j][1][0];\n                  console.log(\"Vertical Match found \" + iterate + \" \" + j + \" to be \" + allpossibilities[iterate][j][1][0]);\n                }\n              }\n            }\n\n            iterate++;\n          } //iterate through column (j) and eliminate content from other possibility arrays\n\n        }\n      } // end for w/ count1\n\n    }\n  } //end for w/ row\n\n\n  return allpossibilities; //return the row if there is a vertical match (new i)\n}","map":{"version":3,"sources":["C:/Users/Steven/Desktop/Workspace/SudokuSolver/src/Tabs/utility.js"],"names":["clearPuzzle","clear","setState","map","alreadyContain","element","array","answer","i","length","oneRule","newMap","j","possible","solution","column","row","isProper","x","Math","trunc","counter1","y","counter2","push","deduction","oldarray","newarray","concat","value1","value2","closerLook","allpossibilities","console","log","reducePossibilities","originalPo","verticalMatch","horizontalMatch","count1","setValue","count2","count3","iterate","remove","indexOf","splice"],"mappings":"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","sourcesContent":["// Container for Sudoku solving strategies\r\n\r\nexport function clearPuzzle() {\r\n    let clear = [[0,0,0,    0,0,0,   0,0,0],\r\n                    [0,0,0,    0,0,0,   0,0,0],\r\n                    [0,0,0,    0,0,0,   0,0,0],\r\n        \r\n                    [0,0,0,    0,0,0,   0,0,0],\r\n                    [0,0,0,    0,0,0,   0,0,0],\r\n                    [0,0,0,    0,0,0,   0,0,0],\r\n\r\n                    [0,0,0,    0,0,0,   0,0,0],\r\n                    [0,0,0,    0,0,0,   0,0,0],\r\n                    [0,0,0,    0,0,0,   0,0,0]];\r\n        \r\n        setState({ map: clear});\r\n}\r\n\r\nexport function alreadyContain(element, array) {\r\n    let answer = false;\r\n        for (let i = 0; i < array.length; i++){\r\n            if (array[i] === element){\r\n                answer = true;\r\n            }\r\n        }//end for\r\n        return answer;\r\n}\r\n\r\nexport function oneRule(newMap, i, j) {\r\n    let possible = [];\r\n    for(let solution = 1; solution !== 10; solution++){\r\n        //            console.log(\"possible array contains \" + possible);\r\n                    let column = 0;\r\n                    let row = 0;\r\n                    let isProper = true;\r\n                    \r\n        \r\n                    while (column !== 9){               //check if current column contains number already\r\n                        if (newMap[i][column] === solution){\r\n                            isProper = false;\r\n                            break;\r\n                        }\r\n                        else if (isProper === false){\r\n                            break;\r\n                        }\r\n                        column++;\r\n                    }  //end while w/ column\r\n        \r\n                    while (row !== 9){\r\n                        if(newMap[row][j] === solution){\r\n                            isProper = false;\r\n                            break;\r\n                        }\r\n                        else if(isProper === false){\r\n                            break;\r\n                        }\r\n                        row++;\r\n                    }  //end while w/ row\r\n                        \r\n                    let x = (Math.trunc(i/3))*3;\r\n                    for (let counter1 = x; counter1 !== x+3; counter1++){\r\n                        let y = (Math.trunc(j/3))*3;\r\n                        for(let counter2 = y; counter2 !== y+3; counter2++){\r\n                            if (newMap[counter1][counter2] === solution){\r\n                                isProper = false; \r\n                                break;\r\n                            }\r\n                        }//end for w/ counter2\r\n                        if (isProper === false){\r\n                            break;\r\n                        }\r\n                    }  //end for w/ counter1 \r\n                    \r\n                    if(isProper !== false){\r\n                        possible.push(solution);\r\n                    }\r\n                  \r\n                }   //end for w/ solution     \r\n    return possible;\r\n}\r\n\r\n\r\n //given a grid, and a set of coords returns a guaranteed answer or leaves space blank\r\n    //oneRule checks vertical, horizontal and 3x3 and holds an array of possibilites based on what it finds...\r\n    //if there is only possibilty it pushes that answer into the cell   \r\nexport function deduction(newMap, i, j, possible) {\r\n    let oldarray = [];\r\n        let x = (Math.trunc(i/3))*3;\r\n            for (let counter1 = x; counter1 !== x+3; counter1++){\r\n                let y = (Math.trunc(j/3))*3;\r\n                for(let counter2 = y; counter2 !== y+3; counter2++){\r\n                   \r\n                    if (newMap[counter1][counter2] !== 0){\r\n                        continue;\r\n                    }\r\n                    else if(counter1 === i && counter2 === j){\r\n                        continue;\r\n                    }\r\n                    else {               \r\n                        let newarray = oneRule(newMap, counter1, counter2);\r\n                        oldarray = newarray.concat(oldarray);\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n        for(let value1 = 0; value1 < possible.length; value1++){    //iterating through what possibilities are in either array\r\n            for(let value2 = 0; value2 < oldarray.length; value2++){\r\n                if(possible[value1] === oldarray[value2]){\r\n                    break;\r\n                }\r\n                if(possible[value1] !== oldarray[value2] && value2 === oldarray.length - 1){\r\n                    return possible[value1];                        //if given index value has one differing value, it is the only possible value\r\n                }\r\n            }\r\n        }\r\n        return 0; //placeholder\r\n}\r\n\r\n\r\nexport function closerLook(newMap) {\r\n    let allpossibilities = [];\r\n\r\n            for(let i = 0; i < newMap.length; i++){\r\n                allpossibilities[i] = [];\r\n                for (let j = 0; j < newMap.length; j++){\r\n                    allpossibilities[i][j] = [];\r\n                    if(newMap[i][j] === 0){\r\n                        allpossibilities[i][j][0] = 0;  //found a cell not filled\r\n                        allpossibilities[i][j][1] = oneRule(newMap, i, j); //call oneRule\r\n                    }\r\n                    else{\r\n                        allpossibilities[i][j][0] = newMap[i][j];   //cell already filled\r\n                        allpossibilities[i][j][1] = 0;  //zero possibilities\r\n                    }\r\n                }\r\n            }\r\n            console.log(\"called\");\r\n    return allpossibilities;\r\n}\r\n\r\nexport function reducePossibilities(allpossibilities, newMap) {\r\n    for (let i = 0; i < allpossibilities.length; i++){\r\n        for (let j = 0; j < allpossibilities[i].length; j++){\r\n            if(allpossibilities[i][j][0] === 0){             //identifies cell to be checked if it is empty\r\n               //look at indexes directly above, below, left and right for a similar possibility\r\n                let originalPo = allpossibilities[i][j][1];\r\n         \r\n                allpossibilities = verticalMatch(originalPo, i, j, allpossibilities, newMap); //look for vertical matches\r\n                allpossibilities = horizontalMatch(originalPo, i, j, allpossibilities, newMap); //look for horizontal matches      \r\n                \r\n            }\r\n            else{\r\n                continue;\r\n            }\r\n        }\r\n    }\r\n\r\n    return allpossibilities;\r\n}\r\n\r\nexport function horizontalMatch(originalPo, i, j, allpossibilities, newMap){\r\n    let x = (Math.trunc(i/3))*3;\r\n    let y = (Math.trunc(j/3))*3;\r\n    for (let column = y; column !== y+3; column++){\r\n        if (j === column){  //if cell is the same\r\n            continue;\r\n        }\r\n        else if (allpossibilities[i][column][1] === 0){ //if cell has zero possibilities... aka already filled\r\n            continue;\r\n        }\r\n        else {      //confirmed the comparing cell is empty and not the same as cell [i][j]\r\n            for (let count1 = 0; count1 < originalPo.length; count1++){\r\n                let setValue = [];\r\n                if(alreadyContain(originalPo[count1], allpossibilities[i][column][1]) !== true){\r\n                    continue;\r\n                }\r\n                else{\r\n                    //check to make sure no indices not in this horizontal (i) have this particular possibility\r\n                    for (let count2 = x; count2 !== x+3; count2++){\r\n                        for (let count3 = y; count3 !== y+3; count3++){\r\n                            if(count2 === i){ // don't look in the same row to determine if to eliminate\r\n                                continue;\r\n                            }\r\n                            if(allpossibilities[count2][count3][1] === 0){   // don't look at already filled cells to determine if to eliminate\r\n                                continue;\r\n                            }\r\n                            if(alreadyContain(originalPo[count1], allpossibilities[count2][count3][1]) === true){ \r\n                                setValue.push(originalPo[count1]);\r\n                            }\r\n                            \r\n                        }// end for w/ count3\r\n                    }// end for w/ count2\r\n                }\r\n                if(alreadyContain(originalPo[count1], setValue) === false){\r\n                    let iterate = 0;\r\n                    while(iterate !== 9){\r\n                        if(alreadyContain(originalPo[count1], allpossibilities[i][iterate][1]) === true){\r\n                            if(iterate !== y && iterate !== y+1 && iterate !== y+2){\r\n                                //remove originalPo[count1] from allpossibilities[iterate][j][1]\r\n                                let remove = allpossibilities[i][iterate][1].indexOf(originalPo[count1]);\r\n                                if (remove > -1){\r\n                                    allpossibilities[i][iterate][1].splice(remove, 1);\r\n                                    console.log(\"Horizontal Match found at \" + i + \" \" + j + \" to reduce possibilities at \" + i + \" \" + iterate + \" to be \" + allpossibilities[i][iterate][1]);\r\n                                }\r\n                                if (allpossibilities[i][iterate][1].length === 1){\r\n                                    newMap[i][iterate] = allpossibilities[i][iterate][1][0];\r\n                                    console.log(\"Horizontal Match found \" + i + \" \" + iterate + \" to be \" + allpossibilities[i][iterate][1][0]);\r\n                                }\r\n                            }\r\n                        }\r\n                        iterate++;\r\n                    }\r\n                    //iterate through column (j) and eliminate content from other possibility arrays\r\n\r\n\r\n                }\r\n                \r\n            }// end for w/ count1\r\n\r\n        }\r\n    \r\n\r\n    }//end for w/ column\r\n    return allpossibilities; //return the row if there is a vertical match (new i)\r\n}\r\n\r\nexport function verticalMatch(originalPo, i, j, allpossibilities, newMap) {\r\n    let x = (Math.trunc(i/3))*3;\r\n        let y = (Math.trunc(j/3))*3;\r\n        for (let row = x; row !== x+3; row++){\r\n            if (i === row){  //if cell is the same\r\n                continue;\r\n            }\r\n            else if (allpossibilities[row][j][1] === 0){ //if cell has zero possibilities... aka already filled\r\n                continue;\r\n            }\r\n            else {      //confirmed the comparing cell is empty and not the same as cell [i][j]\r\n                for (let count1 = 0; count1 < originalPo.length; count1++){\r\n                    let setValue = [];\r\n                    if(alreadyContain(originalPo[count1], allpossibilities[row][j][1]) !== true){\r\n                        continue;\r\n                    }\r\n                    else{\r\n                        //check to make sure no indices not in this vertical (j) have this particular possibility\r\n                        for (let count2 = x; count2 !== x+3; count2++){\r\n                            for (let count3 = y; count3 !== y+3; count3++){\r\n                                if(count3 === j){ // don't look in the same column to determine if to eliminate\r\n                                    continue;\r\n                                }\r\n                                if(allpossibilities[count2][count3][1] === 0){   // don't look at already filled cells to determine if to eliminate\r\n                                    continue;\r\n                                }\r\n                                if(alreadyContain(originalPo[count1], allpossibilities[count2][count3][1]) === true){ \r\n                                    setValue.push(originalPo[count1]);\r\n                                }\r\n                                \r\n                            } //end for w/ count3\r\n                        }// end for w/ count2\r\n                    }\r\n                    if(alreadyContain(originalPo[count1], setValue) === false){\r\n                        \r\n                        let iterate = 0;\r\n                        while(iterate !== 9){\r\n                            if(alreadyContain(originalPo[count1], allpossibilities[iterate][j][1]) === true){\r\n                                if(iterate !== x && iterate !== x+1 && iterate !== x+2){\r\n                                    //remove originalPo[count1] from allpossibilities[iterate][j][1]\r\n                                    let remove = allpossibilities[iterate][j][1].indexOf(originalPo[count1]);\r\n                                    if (remove > -1){\r\n                                        allpossibilities[iterate][j][1].splice(remove, 1);\r\n                                        console.log(\"Vertical Match found at \" + i + \" \" + j + \" to reduce possibilities at \" + iterate + \" \" + j + \" to be \" + allpossibilities[iterate][j][1]);\r\n                                    }\r\n                                    if (allpossibilities[iterate][j][1].length === 1){\r\n                                        newMap[iterate][j] = allpossibilities[iterate][j][1][0];\r\n                                        console.log(\"Vertical Match found \" + iterate + \" \" + j + \" to be \" + allpossibilities[iterate][j][1][0]);\r\n                                    }\r\n                                }\r\n                            }\r\n                            iterate++;\r\n                        }\r\n                        //iterate through column (j) and eliminate content from other possibility arrays\r\n\r\n\r\n                    }\r\n                    \r\n                }// end for w/ count1\r\n\r\n            }\r\n\r\n        }//end for w/ row\r\n        return allpossibilities; //return the row if there is a vertical match (new i)\r\n}\r\n"]},"metadata":{},"sourceType":"module"}