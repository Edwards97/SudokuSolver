{"ast":null,"code":"// Container for Sudoku solving strategies\nexport function oneRule(newMap, i, j) {\n  let possible = [];\n\n  for (let solution = 1; solution !== 10; solution++) {\n    //            console.log(\"possible array contains \" + possible);\n    let column = 0;\n    let row = 0;\n    let isProper = true;\n\n    while (column !== 9) {\n      //check if current column contains number already\n      if (newMap[i][column] === solution) {\n        isProper = false;\n        break;\n      } else if (isProper === false) {\n        break;\n      }\n\n      column++;\n    } //end while w/ column\n\n\n    while (row !== 9) {\n      if (newMap[row][j] === solution) {\n        isProper = false;\n        break;\n      } else if (isProper === false) {\n        break;\n      }\n\n      row++;\n    } //end while w/ row\n\n\n    let x = Math.trunc(i / 3) * 3;\n\n    for (let counter1 = x; counter1 !== x + 3; counter1++) {\n      let y = Math.trunc(j / 3) * 3;\n\n      for (let counter2 = y; counter2 !== y + 3; counter2++) {\n        if (newMap[counter1][counter2] === solution) {\n          isProper = false;\n          break;\n        }\n      } //end for w/ counter2\n\n\n      if (isProper === false) {\n        break;\n      }\n    } //end for w/ counter1 \n\n\n    if (isProper !== false) {\n      possible.push(solution);\n    }\n  } //end for w/ solution     \n\n\n  return possible;\n} //given a grid, and a set of coords returns a guaranteed answer or leaves space blank\n//oneRule checks vertical, horizontal and 3x3 and holds an array of possibilites based on what it finds...\n//if there is only possibilty it pushes that answer into the cell   \n\nexport function deduction(newMap, i, j, possible) {\n  let oldarray = [];\n  let x = Math.trunc(i / 3) * 3;\n\n  for (let counter1 = x; counter1 !== x + 3; counter1++) {\n    let y = Math.trunc(j / 3) * 3;\n\n    for (let counter2 = y; counter2 !== y + 3; counter2++) {\n      if (newMap[counter1][counter2] !== 0) {\n        continue;\n      } else if (counter1 === i && counter2 === j) {\n        continue;\n      } else {\n        let newarray = oneRule(newMap, counter1, counter2);\n        oldarray = newarray.concat(oldarray);\n      }\n    }\n  }\n\n  for (let value1 = 0; value1 < possible.length; value1++) {\n    //iterating through what possibilities are in either array\n    for (let value2 = 0; value2 < oldarray.length; value2++) {\n      if (possible[value1] === oldarray[value2]) {\n        break;\n      }\n\n      if (possible[value1] !== oldarray[value2] && value2 === oldarray.length - 1) {\n        return possible[value1]; //if given index value has one differing value, it is the only possible value\n      }\n    }\n  }\n\n  return 0; //placeholder\n}\nexport function closerLook(newMap) {\n  let allpossibilities = [];\n\n  for (let i = 0; i < newMap.length; i++) {\n    allpossibilities[i] = [];\n\n    for (let j = 0; j < newMap.length; j++) {\n      allpossibilities[i][j] = [];\n\n      if (newMap[i][j] === 0) {\n        allpossibilities[i][j][0] = 0; //found a cell not filled\n\n        allpossibilities[i][j][1] = oneRule(newMap, i, j); //call oneRule\n      } else {\n        allpossibilities[i][j][0] = newMap[i][j]; //cell already filled\n\n        allpossibilities[i][j][1] = 0; //zero possibilities\n      }\n    }\n  }\n\n  console.log(\"called\");\n  return allpossibilities;\n}\nexport function reducePossibilities(allpossibilities, newMap) {\n  for (let i = 0; i < allpossibilities.length; i++) {\n    for (let j = 0; j < allpossibilities[i].length; j++) {\n      if (allpossibilities[i][j][0] === 0) {\n        //identifies cell to be checked if it is empty\n        //look at indexes directly above, below, left and right for a similar possibility\n        let originalPo = allpossibilities[i][j][1];\n        allpossibilities = this.verticalMatch(originalPo, i, j, allpossibilities, newMap); //look for vertical matches\n\n        allpossibilities = horizontalMatch(originalPo, i, j, allpossibilities, newMap); //look for horizontal matches      \n      } else {\n        continue;\n      }\n    }\n  }\n\n  return allpossibilities;\n}\nexport function horizontalMatch(originalPo, i, j, allpossibilities, newMap) {\n  let x = Math.trunc(i / 3) * 3;\n  let y = Math.trunc(j / 3) * 3;\n\n  for (let column = y; column !== y + 3; column++) {\n    if (j === column) {\n      //if cell is the same\n      continue;\n    } else if (allpossibilities[i][column][1] === 0) {\n      //if cell has zero possibilities... aka already filled\n      continue;\n    } else {\n      //confirmed the comparing cell is empty and not the same as cell [i][j]\n      for (let count1 = 0; count1 < originalPo.length; count1++) {\n        let setValue = [];\n\n        if (this.alreadyContain(originalPo[count1], allpossibilities[i][column][1]) !== true) {\n          continue;\n        } else {\n          //check to make sure no indices not in this horizontal (i) have this particular possibility\n          for (let count2 = x; count2 !== x + 3; count2++) {\n            for (let count3 = y; count3 !== y + 3; count3++) {\n              if (count2 === i) {\n                // don't look in the same row to determine if to eliminate\n                continue;\n              }\n\n              if (allpossibilities[count2][count3][1] === 0) {\n                // don't look at already filled cells to determine if to eliminate\n                continue;\n              }\n\n              if (this.alreadyContain(originalPo[count1], allpossibilities[count2][count3][1]) === true) {\n                setValue.push(originalPo[count1]);\n              }\n            } // end for w/ count3\n\n          } // end for w/ count2\n\n        }\n\n        if (this.alreadyContain(originalPo[count1], setValue) === false) {\n          let iterate = 0;\n\n          while (iterate !== 9) {\n            if (this.alreadyContain(originalPo[count1], allpossibilities[i][iterate][1]) === true) {\n              if (iterate !== y && iterate !== y + 1 && iterate !== y + 2) {\n                //remove originalPo[count1] from allpossibilities[iterate][j][1]\n                let remove = allpossibilities[i][iterate][1].indexOf(originalPo[count1]);\n\n                if (remove > -1) {\n                  allpossibilities[i][iterate][1].splice(remove, 1);\n                  console.log(\"Horizontal Match found at \" + i + \" \" + j + \" to reduce possibilities at \" + i + \" \" + iterate + \" to be \" + allpossibilities[i][iterate][1]);\n                }\n\n                if (allpossibilities[i][iterate][1].length === 1) {\n                  newMap[i][iterate] = allpossibilities[i][iterate][1][0];\n                  console.log(\"Horizontal Match found \" + i + \" \" + iterate + \" to be \" + allpossibilities[i][iterate][1][0]);\n                }\n              }\n            }\n\n            iterate++;\n          } //iterate through column (j) and eliminate content from other possibility arrays\n\n        }\n      } // end for w/ count1\n\n    }\n  } //end for w/ column\n\n\n  return allpossibilities; //return the row if there is a vertical match (new i)\n}","map":{"version":3,"sources":["C:/Users/Steven/Desktop/Workspace/SudokuSolver/src/Tabs/utility.js"],"names":["oneRule","newMap","i","j","possible","solution","column","row","isProper","x","Math","trunc","counter1","y","counter2","push","deduction","oldarray","newarray","concat","value1","length","value2","closerLook","allpossibilities","console","log","reducePossibilities","originalPo","verticalMatch","horizontalMatch","count1","setValue","alreadyContain","count2","count3","iterate","remove","indexOf","splice"],"mappings":"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","sourcesContent":["// Container for Sudoku solving strategies\r\n\r\nexport function oneRule(newMap, i, j) {\r\n    let possible = [];\r\n    for(let solution = 1; solution !== 10; solution++){\r\n        //            console.log(\"possible array contains \" + possible);\r\n                    let column = 0;\r\n                    let row = 0;\r\n                    let isProper = true;\r\n                    \r\n        \r\n                    while (column !== 9){               //check if current column contains number already\r\n                        if (newMap[i][column] === solution){\r\n                            isProper = false;\r\n                            break;\r\n                        }\r\n                        else if (isProper === false){\r\n                            break;\r\n                        }\r\n                        column++;\r\n                    }  //end while w/ column\r\n        \r\n                    while (row !== 9){\r\n                        if(newMap[row][j] === solution){\r\n                            isProper = false;\r\n                            break;\r\n                        }\r\n                        else if(isProper === false){\r\n                            break;\r\n                        }\r\n                        row++;\r\n                    }  //end while w/ row\r\n                        \r\n                    let x = (Math.trunc(i/3))*3;\r\n                    for (let counter1 = x; counter1 !== x+3; counter1++){\r\n                        let y = (Math.trunc(j/3))*3;\r\n                        for(let counter2 = y; counter2 !== y+3; counter2++){\r\n                            if (newMap[counter1][counter2] === solution){\r\n                                isProper = false; \r\n                                break;\r\n                            }\r\n                        }//end for w/ counter2\r\n                        if (isProper === false){\r\n                            break;\r\n                        }\r\n                    }  //end for w/ counter1 \r\n                    \r\n                    if(isProper !== false){\r\n                        possible.push(solution);\r\n                    }\r\n                  \r\n                }   //end for w/ solution     \r\n    return possible;\r\n}\r\n\r\n\r\n //given a grid, and a set of coords returns a guaranteed answer or leaves space blank\r\n    //oneRule checks vertical, horizontal and 3x3 and holds an array of possibilites based on what it finds...\r\n    //if there is only possibilty it pushes that answer into the cell   \r\nexport function deduction(newMap, i, j, possible) {\r\n    let oldarray = [];\r\n        let x = (Math.trunc(i/3))*3;\r\n            for (let counter1 = x; counter1 !== x+3; counter1++){\r\n                let y = (Math.trunc(j/3))*3;\r\n                for(let counter2 = y; counter2 !== y+3; counter2++){\r\n                   \r\n                    if (newMap[counter1][counter2] !== 0){\r\n                        continue;\r\n                    }\r\n                    else if(counter1 === i && counter2 === j){\r\n                        continue;\r\n                    }\r\n                    else {               \r\n                        let newarray = oneRule(newMap, counter1, counter2);\r\n                        oldarray = newarray.concat(oldarray);\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n        for(let value1 = 0; value1 < possible.length; value1++){    //iterating through what possibilities are in either array\r\n            for(let value2 = 0; value2 < oldarray.length; value2++){\r\n                if(possible[value1] === oldarray[value2]){\r\n                    break;\r\n                }\r\n                if(possible[value1] !== oldarray[value2] && value2 === oldarray.length - 1){\r\n                    return possible[value1];                        //if given index value has one differing value, it is the only possible value\r\n                }\r\n            }\r\n        }\r\n        return 0; //placeholder\r\n}\r\n\r\n\r\nexport function closerLook(newMap) {\r\n    let allpossibilities = [];\r\n\r\n            for(let i = 0; i < newMap.length; i++){\r\n                allpossibilities[i] = [];\r\n                for (let j = 0; j < newMap.length; j++){\r\n                    allpossibilities[i][j] = [];\r\n                    if(newMap[i][j] === 0){\r\n                        allpossibilities[i][j][0] = 0;  //found a cell not filled\r\n                        allpossibilities[i][j][1] = oneRule(newMap, i, j); //call oneRule\r\n                    }\r\n                    else{\r\n                        allpossibilities[i][j][0] = newMap[i][j];   //cell already filled\r\n                        allpossibilities[i][j][1] = 0;  //zero possibilities\r\n                    }\r\n                }\r\n            }\r\n            console.log(\"called\");\r\n    return allpossibilities;\r\n}\r\n\r\nexport function reducePossibilities(allpossibilities, newMap) {\r\n    for (let i = 0; i < allpossibilities.length; i++){\r\n        for (let j = 0; j < allpossibilities[i].length; j++){\r\n            if(allpossibilities[i][j][0] === 0){             //identifies cell to be checked if it is empty\r\n               //look at indexes directly above, below, left and right for a similar possibility\r\n                let originalPo = allpossibilities[i][j][1];\r\n         \r\n                allpossibilities = this.verticalMatch(originalPo, i, j, allpossibilities, newMap); //look for vertical matches\r\n                allpossibilities = horizontalMatch(originalPo, i, j, allpossibilities, newMap); //look for horizontal matches      \r\n                \r\n            }\r\n            else{\r\n                continue;\r\n            }\r\n        }\r\n    }\r\n\r\n    return allpossibilities;\r\n}\r\n\r\nexport function horizontalMatch(originalPo, i, j, allpossibilities, newMap){\r\n    let x = (Math.trunc(i/3))*3;\r\n    let y = (Math.trunc(j/3))*3;\r\n    for (let column = y; column !== y+3; column++){\r\n        if (j === column){  //if cell is the same\r\n            continue;\r\n        }\r\n        else if (allpossibilities[i][column][1] === 0){ //if cell has zero possibilities... aka already filled\r\n            continue;\r\n        }\r\n        else {      //confirmed the comparing cell is empty and not the same as cell [i][j]\r\n            for (let count1 = 0; count1 < originalPo.length; count1++){\r\n                let setValue = [];\r\n                if(this.alreadyContain(originalPo[count1], allpossibilities[i][column][1]) !== true){\r\n                    continue;\r\n                }\r\n                else{\r\n                    //check to make sure no indices not in this horizontal (i) have this particular possibility\r\n                    for (let count2 = x; count2 !== x+3; count2++){\r\n                        for (let count3 = y; count3 !== y+3; count3++){\r\n                            if(count2 === i){ // don't look in the same row to determine if to eliminate\r\n                                continue;\r\n                            }\r\n                            if(allpossibilities[count2][count3][1] === 0){   // don't look at already filled cells to determine if to eliminate\r\n                                continue;\r\n                            }\r\n                            if(this.alreadyContain(originalPo[count1], allpossibilities[count2][count3][1]) === true){ \r\n                                setValue.push(originalPo[count1]);\r\n                            }\r\n                            \r\n                        }// end for w/ count3\r\n                    }// end for w/ count2\r\n                }\r\n                if(this.alreadyContain(originalPo[count1], setValue) === false){\r\n                    let iterate = 0;\r\n                    while(iterate !== 9){\r\n                        if(this.alreadyContain(originalPo[count1], allpossibilities[i][iterate][1]) === true){\r\n                            if(iterate !== y && iterate !== y+1 && iterate !== y+2){\r\n                                //remove originalPo[count1] from allpossibilities[iterate][j][1]\r\n                                let remove = allpossibilities[i][iterate][1].indexOf(originalPo[count1]);\r\n                                if (remove > -1){\r\n                                    allpossibilities[i][iterate][1].splice(remove, 1);\r\n                                    console.log(\"Horizontal Match found at \" + i + \" \" + j + \" to reduce possibilities at \" + i + \" \" + iterate + \" to be \" + allpossibilities[i][iterate][1]);\r\n                                }\r\n                                if (allpossibilities[i][iterate][1].length === 1){\r\n                                    newMap[i][iterate] = allpossibilities[i][iterate][1][0];\r\n                                    console.log(\"Horizontal Match found \" + i + \" \" + iterate + \" to be \" + allpossibilities[i][iterate][1][0]);\r\n                                }\r\n                            }\r\n                        }\r\n                        iterate++;\r\n                    }\r\n                    //iterate through column (j) and eliminate content from other possibility arrays\r\n\r\n\r\n                }\r\n                \r\n            }// end for w/ count1\r\n\r\n        }\r\n    \r\n\r\n    }//end for w/ column\r\n    return allpossibilities; //return the row if there is a vertical match (new i)\r\n}\r\n"]},"metadata":{},"sourceType":"module"}