{"ast":null,"code":"import React, { Component } from \"react\"; // Container for Sudoku solving strategies\n\nexport function oneRule(newMap, i, j) {\n  let possible = [];\n\n  for (let solution = 1; solution !== 10; solution++) {\n    //            console.log(\"possible array contains \" + possible);\n    let column = 0;\n    let row = 0;\n    let isProper = true;\n\n    while (column !== 9) {\n      //check if current column contains number already\n      if (newMap[i][column] === solution) {\n        isProper = false;\n        break;\n      } else if (isProper === false) {\n        break;\n      }\n\n      column++;\n    } //end while w/ column\n\n\n    while (row !== 9) {\n      if (newMap[row][j] === solution) {\n        isProper = false;\n        break;\n      } else if (isProper === false) {\n        break;\n      }\n\n      row++;\n    } //end while w/ row\n\n\n    let x = Math.trunc(i / 3) * 3;\n\n    for (let counter1 = x; counter1 !== x + 3; counter1++) {\n      let y = Math.trunc(j / 3) * 3;\n\n      for (let counter2 = y; counter2 !== y + 3; counter2++) {\n        if (newMap[counter1][counter2] === solution) {\n          isProper = false;\n          break;\n        }\n      } //end for w/ counter2\n\n\n      if (isProper === false) {\n        break;\n      }\n    } //end for w/ counter1 \n\n\n    if (isProper !== false) {\n      possible.push(solution);\n    }\n  } //end for w/ solution     \n\n\n  return possible;\n} //given a grid, and a set of coords returns a guaranteed answer or leaves space blank\n//oneRule checks vertical, horizontal and 3x3 and holds an array of possibilites based on what it finds...\n//if there is only possibilty it pushes that answer into the cell   \n\nexport function deduction(newMap, i, j, possible) {\n  let oldarray = [];\n  let x = Math.trunc(i / 3) * 3;\n\n  for (let counter1 = x; counter1 !== x + 3; counter1++) {\n    let y = Math.trunc(j / 3) * 3;\n\n    for (let counter2 = y; counter2 !== y + 3; counter2++) {\n      if (newMap[counter1][counter2] !== 0) {\n        continue;\n      } else if (counter1 === i && counter2 === j) {\n        continue;\n      } else {\n        let newarray = oneRule(newMap, counter1, counter2);\n        oldarray = newarray.concat(oldarray);\n      }\n    }\n  }\n\n  for (let value1 = 0; value1 < possible.length; value1++) {\n    //iterating through what possibilities are in either array\n    for (let value2 = 0; value2 < oldarray.length; value2++) {\n      if (possible[value1] === oldarray[value2]) {\n        break;\n      }\n\n      if (possible[value1] !== oldarray[value2] && value2 === oldarray.length - 1) {\n        return possible[value1]; //if given index value has one differing value, it is the only possible value\n      }\n    }\n  }\n\n  return 0; //placeholder\n}","map":{"version":3,"sources":["C:/Users/Steven/Desktop/Workspace/SudokuSolver/src/Tabs/utility.js"],"names":["React","Component","oneRule","newMap","i","j","possible","solution","column","row","isProper","x","Math","trunc","counter1","y","counter2","push","deduction","oldarray","newarray","concat","value1","length","value2"],"mappings":"AAAA,OAAOA,KAAP,IAAgBC,SAAhB,QAAiC,OAAjC,C,CAEA;;AACA,OAAO,SAASC,OAAT,CAAiBC,MAAjB,EAAyBC,CAAzB,EAA4BC,CAA5B,EAA+B;AAClC,MAAIC,QAAQ,GAAG,EAAf;;AACA,OAAI,IAAIC,QAAQ,GAAG,CAAnB,EAAsBA,QAAQ,KAAK,EAAnC,EAAuCA,QAAQ,EAA/C,EAAkD;AAC9C;AACY,QAAIC,MAAM,GAAG,CAAb;AACA,QAAIC,GAAG,GAAG,CAAV;AACA,QAAIC,QAAQ,GAAG,IAAf;;AAGA,WAAOF,MAAM,KAAK,CAAlB,EAAoB;AAAgB;AAChC,UAAIL,MAAM,CAACC,CAAD,CAAN,CAAUI,MAAV,MAAsBD,QAA1B,EAAmC;AAC/BG,QAAAA,QAAQ,GAAG,KAAX;AACA;AACH,OAHD,MAIK,IAAIA,QAAQ,KAAK,KAAjB,EAAuB;AACxB;AACH;;AACDF,MAAAA,MAAM;AACT,KAhBiC,CAgB/B;;;AAEH,WAAOC,GAAG,KAAK,CAAf,EAAiB;AACb,UAAGN,MAAM,CAACM,GAAD,CAAN,CAAYJ,CAAZ,MAAmBE,QAAtB,EAA+B;AAC3BG,QAAAA,QAAQ,GAAG,KAAX;AACA;AACH,OAHD,MAIK,IAAGA,QAAQ,KAAK,KAAhB,EAAsB;AACvB;AACH;;AACDD,MAAAA,GAAG;AACN,KA3BiC,CA2B/B;;;AAEH,QAAIE,CAAC,GAAIC,IAAI,CAACC,KAAL,CAAWT,CAAC,GAAC,CAAb,CAAD,GAAkB,CAA1B;;AACA,SAAK,IAAIU,QAAQ,GAAGH,CAApB,EAAuBG,QAAQ,KAAKH,CAAC,GAAC,CAAtC,EAAyCG,QAAQ,EAAjD,EAAoD;AAChD,UAAIC,CAAC,GAAIH,IAAI,CAACC,KAAL,CAAWR,CAAC,GAAC,CAAb,CAAD,GAAkB,CAA1B;;AACA,WAAI,IAAIW,QAAQ,GAAGD,CAAnB,EAAsBC,QAAQ,KAAKD,CAAC,GAAC,CAArC,EAAwCC,QAAQ,EAAhD,EAAmD;AAC/C,YAAIb,MAAM,CAACW,QAAD,CAAN,CAAiBE,QAAjB,MAA+BT,QAAnC,EAA4C;AACxCG,UAAAA,QAAQ,GAAG,KAAX;AACA;AACH;AACJ,OAP+C,CAO/C;;;AACD,UAAIA,QAAQ,KAAK,KAAjB,EAAuB;AACnB;AACH;AACJ,KAzCiC,CAyC/B;;;AAEH,QAAGA,QAAQ,KAAK,KAAhB,EAAsB;AAClBJ,MAAAA,QAAQ,CAACW,IAAT,CAAcV,QAAd;AACH;AAEJ,GAjDqB,CAiDlB;;;AAChB,SAAOD,QAAP;AACH,C,CAGA;AACG;AACA;;AACJ,OAAO,SAASY,SAAT,CAAmBf,MAAnB,EAA2BC,CAA3B,EAA8BC,CAA9B,EAAiCC,QAAjC,EAA2C;AAC9C,MAAIa,QAAQ,GAAG,EAAf;AACI,MAAIR,CAAC,GAAIC,IAAI,CAACC,KAAL,CAAWT,CAAC,GAAC,CAAb,CAAD,GAAkB,CAA1B;;AACI,OAAK,IAAIU,QAAQ,GAAGH,CAApB,EAAuBG,QAAQ,KAAKH,CAAC,GAAC,CAAtC,EAAyCG,QAAQ,EAAjD,EAAoD;AAChD,QAAIC,CAAC,GAAIH,IAAI,CAACC,KAAL,CAAWR,CAAC,GAAC,CAAb,CAAD,GAAkB,CAA1B;;AACA,SAAI,IAAIW,QAAQ,GAAGD,CAAnB,EAAsBC,QAAQ,KAAKD,CAAC,GAAC,CAArC,EAAwCC,QAAQ,EAAhD,EAAmD;AAE/C,UAAIb,MAAM,CAACW,QAAD,CAAN,CAAiBE,QAAjB,MAA+B,CAAnC,EAAqC;AACjC;AACH,OAFD,MAGK,IAAGF,QAAQ,KAAKV,CAAb,IAAkBY,QAAQ,KAAKX,CAAlC,EAAoC;AACrC;AACH,OAFI,MAGA;AACD,YAAIe,QAAQ,GAAGlB,OAAO,CAACC,MAAD,EAASW,QAAT,EAAmBE,QAAnB,CAAtB;AACAG,QAAAA,QAAQ,GAAGC,QAAQ,CAACC,MAAT,CAAgBF,QAAhB,CAAX;AAEH;AACJ;AACJ;;AAEL,OAAI,IAAIG,MAAM,GAAG,CAAjB,EAAoBA,MAAM,GAAGhB,QAAQ,CAACiB,MAAtC,EAA8CD,MAAM,EAApD,EAAuD;AAAK;AACxD,SAAI,IAAIE,MAAM,GAAG,CAAjB,EAAoBA,MAAM,GAAGL,QAAQ,CAACI,MAAtC,EAA8CC,MAAM,EAApD,EAAuD;AACnD,UAAGlB,QAAQ,CAACgB,MAAD,CAAR,KAAqBH,QAAQ,CAACK,MAAD,CAAhC,EAAyC;AACrC;AACH;;AACD,UAAGlB,QAAQ,CAACgB,MAAD,CAAR,KAAqBH,QAAQ,CAACK,MAAD,CAA7B,IAAyCA,MAAM,KAAKL,QAAQ,CAACI,MAAT,GAAkB,CAAzE,EAA2E;AACvE,eAAOjB,QAAQ,CAACgB,MAAD,CAAf,CADuE,CACvB;AACnD;AACJ;AACJ;;AACD,SAAO,CAAP,CA/B0C,CA+BhC;AACjB","sourcesContent":["import React, { Component } from \"react\";\r\n\r\n// Container for Sudoku solving strategies\r\nexport function oneRule(newMap, i, j) {\r\n    let possible = [];\r\n    for(let solution = 1; solution !== 10; solution++){\r\n        //            console.log(\"possible array contains \" + possible);\r\n                    let column = 0;\r\n                    let row = 0;\r\n                    let isProper = true;\r\n                    \r\n        \r\n                    while (column !== 9){               //check if current column contains number already\r\n                        if (newMap[i][column] === solution){\r\n                            isProper = false;\r\n                            break;\r\n                        }\r\n                        else if (isProper === false){\r\n                            break;\r\n                        }\r\n                        column++;\r\n                    }  //end while w/ column\r\n        \r\n                    while (row !== 9){\r\n                        if(newMap[row][j] === solution){\r\n                            isProper = false;\r\n                            break;\r\n                        }\r\n                        else if(isProper === false){\r\n                            break;\r\n                        }\r\n                        row++;\r\n                    }  //end while w/ row\r\n                        \r\n                    let x = (Math.trunc(i/3))*3;\r\n                    for (let counter1 = x; counter1 !== x+3; counter1++){\r\n                        let y = (Math.trunc(j/3))*3;\r\n                        for(let counter2 = y; counter2 !== y+3; counter2++){\r\n                            if (newMap[counter1][counter2] === solution){\r\n                                isProper = false; \r\n                                break;\r\n                            }\r\n                        }//end for w/ counter2\r\n                        if (isProper === false){\r\n                            break;\r\n                        }\r\n                    }  //end for w/ counter1 \r\n                    \r\n                    if(isProper !== false){\r\n                        possible.push(solution);\r\n                    }\r\n                  \r\n                }   //end for w/ solution     \r\n    return possible;\r\n}\r\n\r\n\r\n //given a grid, and a set of coords returns a guaranteed answer or leaves space blank\r\n    //oneRule checks vertical, horizontal and 3x3 and holds an array of possibilites based on what it finds...\r\n    //if there is only possibilty it pushes that answer into the cell   \r\nexport function deduction(newMap, i, j, possible) {\r\n    let oldarray = [];\r\n        let x = (Math.trunc(i/3))*3;\r\n            for (let counter1 = x; counter1 !== x+3; counter1++){\r\n                let y = (Math.trunc(j/3))*3;\r\n                for(let counter2 = y; counter2 !== y+3; counter2++){\r\n                   \r\n                    if (newMap[counter1][counter2] !== 0){\r\n                        continue;\r\n                    }\r\n                    else if(counter1 === i && counter2 === j){\r\n                        continue;\r\n                    }\r\n                    else {               \r\n                        let newarray = oneRule(newMap, counter1, counter2);\r\n                        oldarray = newarray.concat(oldarray);\r\n\r\n                    }\r\n                }\r\n            }\r\n\r\n        for(let value1 = 0; value1 < possible.length; value1++){    //iterating through what possibilities are in either array\r\n            for(let value2 = 0; value2 < oldarray.length; value2++){\r\n                if(possible[value1] === oldarray[value2]){\r\n                    break;\r\n                }\r\n                if(possible[value1] !== oldarray[value2] && value2 === oldarray.length - 1){\r\n                    return possible[value1];                        //if given index value has one differing value, it is the only possible value\r\n                }\r\n            }\r\n        }\r\n        return 0; //placeholder\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}